/***************************************************************************
 *
 *   RunUO                   : May 1, 2002
 *   portions copyright      : (C) The RunUO Software Team
 *   email                   : info@runuo.com
 *   
 *   Angel Island UO Shard   : March 25, 2004
 *   portions copyright      : (C) 2004-2024 Tomasello Software LLC.
 *   email                   : luke@tomasello.com
 *
 ***************************************************************************/

/***************************************************************************
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 ***************************************************************************/

/* Scripts/Misc/ExploitTracking.cs
 * ChangeLog
 *  9/15/2023, Adam QuantumLeap_EventSink)
 *      Add FloorZ() to determine if stepping onto something movable that would raise us above the floor
 *  4/26/23, Yoar
 *      Generalization of SnowPileExploit. Foot stools, unlike snow piles, have a height of 1.
 *      We must therefore account for the item height when checking if we're stepping off/
 *      onto item.
 *  9/10/21, Yoar
 *      Bug fix in HoverExploit
 *      - Intent: If we detect that a mobile is hovering, drop the mobile to a tile below them.
 *        We use the method TileAtZ to see if there's a tile at a particular z coordinate.
 *      - Problem: In TileAtZ, the height of the static tile is not taken into account,
 *        resulting in the mobile getting dropped to tile.Z. For tiles that have a height > 0,
 *        this means that the mobile is dropped *inside* of the tile.
 *        Notably, this is a problem for ship decks, which have a height of 3.
 *      - Fix: Stop dropping the mobile at tile.Z + itemData.CalcHeight. But, to avoid any
 *        adverse effects, let's only use this fix for surface tiles.
 *	5/23/10
 *		BlockAndReport() : sending in-game staff messages
 *		was getting this spam during an event I was recording.
 *		lets reserve the logging for postmortem analysis.
 *	3/16/10, adam
 *		convert use of pooled enumerable to a simple enumerations of clients in the sector at X/Y
 *		Hopfully this will solve the ongoing saga of the HoverExploit exception problem.
 *	4/16/09, Adam
 *		Remove HoverExploit exception logging.
 *		We know it's a problem, but its polluting the damn exception log.
 *	12/10/08, Adam
 *		Seeing some weird exceptions having to do with PooledEnumerable :\
 *		Undoing the hack.
 *		We will keep an eye on this
 *	12/09/08, Adam
 *		ExploitTracking still complaining about GetEnumerator() called after Free(). Add a special hack to delete the eable *later*
 *			i.e., new FreeHack(eable);
 *		We will keep an eye on this
 *	10/9/08, Adam
 *		- Share iStack in SpellHelper, and fix it to free the pooled enumerable in all cases
 *		- We've seen the HoverExploit exception as recently as 9/29/2008, meaning our last fix did not address the problem.
 *		We are therefore reinstating the pooled enumerator free() and adding an exception handler to catch the error.
 *		We will continue to monitor this issue.
 *		Log start : 9/29/2008 2:36:24 PM
 *	GetEnumerator() called after Free()
 *	Object name: 'PooledEnumerable'.
 *    at Server.Map.PooledEnumerable.GetEnumerator()
 *    at Server.Misc.ExploitTracking.HoverExploit(Map map, Int32 x, Int32 y)
 *    at Server.Misc.ExploitTracking.EventSink_DropMobile(DropMobileEventArgs e)
 *    at Server.EventSink.InvokeDropMobile(DropMobileEventArgs e)
 *	Completed in 0.125 seconds, 1 entry logged
 *  9/21/08, Adam
 *      Don't call the pooled enumerator free() function from HoverExploit() because HoverExploit() can DropsTheMobile which can
 *      call HoverExploit. iPooledEnumerable IS NOT RE-ENTRANT :(
 *      Note: iPooledEnumerable needs to be made reentrant
 *      PS. iPooledEnumerable's Dispose() will call free(), so the data will get cleaned up, just a bit later.
 *  8/5/08, Adam
 *      When dropping the mobile in HoverExploit, make sure to stop when you hit a static tile
 *	7/18/08, Adam
 *		Initial version
 */

/*
    These movement exploit handlers are purposefully kept separate from other movement exploits to keep the logic as manageable as possible.
    I'll try to explain what we are doing here:

    General Notes:
    Since these routines are called for every mobile movement, it is critical that it be as fast as possible; because of this we 'short circuit' the logic as ASAP to minimize the impact.
    One notable optimization is NOT removing dossier entries if the player steps OFF a stack of movable items.
    it's likely to 'clear them of any wrong doing', but the overhead of carrying that entry is small and not worth the cleanup.

    --

    #SnowPileExploit_EventSink:
    In the snowpile and potion bottle exploit, the items can be stacked. The player stands on Pile-A and builds Pile-B, then steps UP onto Pile-B and builds Pile-A, and repeats until they have reached a Z which either gives them direct access to lockboxes, or the ability to step off into an area or teleport into a courtyard.

    Counter Measure::
    If the player is stepping off a pile of movable items onto a pile of movable items and they are moving UP in the Z plane, we count to 3 and block further movement.

    Why Count to 3?:
    We count to 3 to avoid false positives, like if someone is running around outside of Wrong and is stepping on tons of assorted crap, corpses, bottles, hides, body parts, etc.. it's possible to trigger a singe stack-to-stack Z UP.

    --
 
    #QuantumLeap_EventSink:

    In the QuantumLeap exploit, the player is stepping off a porch or other structure at say Z=5 UP onto a stack of snowpiles maybe Z=7, this means that players can get to Z=13 before SnowPileExploit fires. 
    Rather and eliminate the 'Count to 3' clause, we handle this 'stepping off a static tile' case with the following logic: If the pile being stepped onto has a delta > 3 Z, issue a Penalty effectively decreasing their 3 STRIKES-AND-YOU'RE-OUT  allowance to 2.
    It's complicated by the fact that we don't want to prohibit homeowners from messing around in their own homes.

    Counter Measure1 - static tile to land tile::
    This is the case where the player steps off of someone else's porch onto a stack of movable items in order to gain Z.

    Here we look to see if the place they are moving OFF of is a static tile (house or other multi) and that they are gaining Z by stepping onto a stack of movable items which are NOT on a static tile.

    Counter Measure2- static tile to static tile::
    This is the case where the player builds piles of movable items on someone else's property in order to climb them to gain Z

    Here we look to see if the place they are moving OFF of is a static tile (house or other multi) and that they are gaining Z by stepping onto a stack of movable items which are ALSO on a static tile.
 */

using Server.Commands;
using Server.Mobiles;
using Server.Multis;
using Server.Network;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using static Server.Utility;

namespace Server.Misc
{
    public class ExploitTracking
    {
        private static Dictionary<Serial, Dossier> m_doissier = new Dictionary<Serial, Dossier>();

        public static void Initialize()
        {
            EventSink.Movement += new MovementEventHandler(SnowPileExploit_EventSink);
            EventSink.Movement += new MovementEventHandler(QuantumLeap_EventSink);
            EventSink.DropMobile += new DropMobileEventHandler(EventSink_DropMobile);
            EventSink.Login += new LoginEventHandler(OnLogin);
        }

        public static void OnLogin(LoginEventArgs e)
        {
            if (e.Mobile != null && e.Mobile.NetState != null && e.Mobile.Map != null && e.Mobile.Map != Map.Internal)
                if (CanSpawnLandMobile(e.Mobile.Map, e.Mobile.Location, CanFitFlags.requireSurface) == false)
                {
                    HoverExploit(e.Mobile.Map, e.Mobile.Location.X, e.Mobile.Location.Y);
                }
        }

        static void EventSink_DropMobile(DropMobileEventArgs e)
        {
            HoverExploit(e.Map, e.X, e.Y);
        }

        static void HoverExploit(Map map, int x, int y)
        {
            try
            {
                Point3D location = new Point3D(x, y, 0);
                StaticTile[] tiles = map.Tiles.GetStaticTiles(x, y, true);
                ArrayList list = new ArrayList();

                Sector sector = map.GetSector(x, y);
                if (sector != null && sector.Clients != null)
                {
                    foreach (NetState ns in sector.Clients)
                    {
                        if (ns == null || ns.Mobile == null || ns.Mobile.X != x || ns.Mobile.Y != y)
                            continue;
                        list.Add(ns.Mobile);
                    }
                }

                for (int ix = 0; ix < list.Count; ix++)
                {
                    Mobile m = list[ix] as Mobile;
                    if (CanSpawnLandMobile(map, m.Location, CanFitFlags.requireSurface) == false)
                    {
                        // Console.WriteLine("Bogus man!!");
                        //int averageZ = map.GetAverageZ(m.Location.X, m.Location.Y);
                        int averageZ = 0, topZ = 0, z = 0;
                        map.GetAverageZ(m.Location.X, m.Location.Y, ref z, ref averageZ, ref topZ);
                        while (m.Location.Z > averageZ && TileAtZ(tiles, m.Z) == false)
                        {   // drop the player down a notch
                            Point3D newLocation = new Point3D(m.Location);
                            newLocation.Z--;
                            m.MoveToWorld(newLocation, m.Map);
                            if (CanSpawnLandMobile(map, m.Location, CanFitFlags.requireSurface) == true)
                                break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // adam: stop logging this to the exception file as it's polluting it.
                // we still need to fix it tho .. meh
                Console.WriteLine(ex.ToString());
                // EventSink.InvokeLogException(new LogExceptionEventArgs(ex)); 
            }

            return;
        }

        static bool TileAtZ(StaticTile[] tiles, int z)
        {
            for (int j = 0; j < tiles.Length; ++j)
            {
                StaticTile tile = tiles[j];

                int tileZ = tile.Z;

                ItemData id = TileData.ItemTable[tile.ID & 0x3FFF];

                if (id.Surface)
                    tileZ += id.CalcHeight;

                if (tileZ == z)
                    return true;
            }

            return false;
        }

        // dictionary of players, indexed on the player's serial number.
        //  This structure tracks the player, the number of infraction (suspicious movements.)
        //  and a timeout value, basically when we can forget what was done and reset
        private class Dossier
        {
            private DateTime m_timestamp;
            public Dossier() { m_timestamp = DateTime.UtcNow; }
            public bool Timeout { get { return DateTime.UtcNow - m_timestamp > TimeSpan.FromMinutes(60); } }
            public void MarkTime() { m_timestamp = DateTime.UtcNow; }
            private int m_infractionCount;
            public int InfractionCount { get { return m_infractionCount; } set { m_infractionCount = value; } }
        }

        public static void SnowPileExploit_EventSink(MovementEventArgs e)
        {
            Mobile from = e.Mobile;

            if (!from.Player || from is PlayerMobile == false)
                return;

            try
            {
                // Okay.. Look to see if a player is standing on a stack of movable items and is about to 
                //  step UP onto another stack of movable items. If the player does this three times.
                //  block their movment, alert staff, and log the cheaters

                // the tile we are stepping off of
                bool step_off = false;
                IPooledEnumerable from_list = from.Map.GetItemsInRange(from.Location, 0);
                foreach (Item ix in from_list)
                {
                    if (ix is Item == false) continue;
                    //Console.WriteLine("OFF:{0}", ix);
                    if (ix.Z + ix.ItemData.CalcHeight == from.Z && ix.Movable == true)
                    {   // we are stepping off of a movable item at OUR Z
                        step_off = true;
                        break;
                    }
                }
                from_list.Free();

                // short circuit to make this code min impact
                if (step_off == false)
                    return;

                // calc where we want to go
                Point3D dest = new Point3D(from.Location);
                int x = dest.X;
                int y = dest.Y;
                Movement.Movement.Offset(e.Direction, ref x, ref y);
                dest.X = x;
                dest.Y = y;

                // the tile we are stepping on to
                bool step_onto = false;
                IPooledEnumerable to_list = from.Map.GetItemsInRange(dest, 0);
                foreach (Item ix in to_list)
                {   // we only trap UP movement. If you want UP/DOWN, change ix.Z > from.Z to ix.Z != from.Z
                    if (ix is Item == false) continue;
                    //Console.WriteLine("ON:{0}",ix);
                    if (ix.Z + ix.ItemData.CalcHeight > from.Z && ix.Movable == true)
                    {   // we are stepping onto a movable item at GREATER than OUR Z
                        step_onto = true;
                        break;
                    }
                }
                to_list.Free();

                // short circuit to make this code min impact
                if (step_onto == false)
                    return;

                // verify if we are climbing in the Z plane
                int newZ = 0;
                bool ClimbingZPlane = false;
                from.CheckMovement(e.Direction, out newZ);
                if (newZ > from.Z)
                {   // make sure there are at least 2 items in this stack at different Zs
                    if (Spells.SpellHelper.iStack(from, dest, 2) == false)
                        ClimbingZPlane = true;
                }
                //Console.WriteLine("Stepping {0}", newZ > from.Z ? "UP" : "Down");

                // short circuit to make this code min impact
                if (ClimbingZPlane == true)
                {
                    // if the stack we are stepping off has a delta > 3 for some reason generate a Penalty point
                    bool Penalty = false;
                    if (from.Z - from.Map.GetAverageZ(from.X, from.Y) > 3)
                        Penalty = true;

                    // Okay here is what we know so far.. we are standing on movable objects stepping UP in the Z Plane
                    //  onto MORE movable items .. this looks exploitive.
                    TrackPlayer(e, Penalty);
                }

                return;
            }
            catch (Exception ex) { EventSink.InvokeLogException(new LogExceptionEventArgs(ex)); }
        }

        public static void QuantumLeap_EventSink(MovementEventArgs e)
        {
            Mobile from = e.Mobile;

            if (!from.Player || from is PlayerMobile == false)
                return;

            try
            {
                // is there a multi where we are stepping off?
                bool step_off_tile = false;
                IPooledEnumerable<StaticTile[]> tile_from_list = from.Map.GetMultiTilesAt(from.Location.X, from.Location.Y);
                foreach (StaticTile[] ix in tile_from_list)
                {
                    step_off_tile = Server.Items.BaseMulti.Find(from.Location, from.Map) != null; break;
                }
                tile_from_list.Free();

                // short circuit
                if (step_off_tile == false)
                    return;

                // calc where we want to go
                Point3D dest = new Point3D(from.Location);
                int x = dest.X;
                int y = dest.Y;
                Movement.Movement.Offset(e.Direction, ref x, ref y);
                dest.X = x;
                dest.Y = y;

                // is there a tile where we are stepping on?
                bool step_on_tile = false;
                IPooledEnumerable<StaticTile[]> tile_to_list = from.Map.GetMultiTilesAt(dest.X, dest.Y);
                foreach (StaticTile[] ix in tile_to_list) { step_on_tile = Server.Items.BaseMulti.Find(dest, from.Map) != null; break; }
                tile_to_list.Free();

                // case: stepping off a porch (or other multi) onto a stack of stacked item outside multi
                if (step_off_tile == true && step_on_tile == false)
                {
                    // see if we are stepping onto a stack of movable items
                    // the tile we are stepping on to
                    bool step_onto = false;
                    IPooledEnumerable to_list = from.Map.GetItemsInRange(dest, 0);
                    foreach (Item ix in to_list)
                    {   // we only trap UP movement. If you want UP/DOWN, change ix.Z > from.Z to ix.Z != from.Z
                        if (ix is Item == false) continue;
                        //Console.WriteLine("ON:{0}",ix);
                        if (ix.Z >= from.Z && ix.Movable == true)
                        {   // we are stepping onto a movable item at >= OUR Z
                            step_onto = true;
                            break;
                        }
                    }
                    to_list.Free();

                    // we will be stepping off a porch onto a stack of movable items, see if we will be climbing
                    if (step_onto == true)
                    {
                        // verify if we are climbing in the Z plane
                        int newZ = 0;
                        bool ClimbingZPlane = false;
                        from.CheckMovement(e.Direction, out newZ);
                        if (newZ > from.Z)
                        {   // make sure there are at least 2 items in this stack at different Zs
                            if (Spells.SpellHelper.iStack(from, dest, 2) == false)
                                ClimbingZPlane = true;
                        }

                        // if we are climbing the z plane
                        if (ClimbingZPlane == true)
                            // if we are the owner, we allow this
                            if (from.Region is Regions.HouseRegion)
                            {   // get the house
                                BaseHouse bh = (from.Region as Regions.HouseRegion).House;
                                // if we are not a friend of this house, block and report
                                if (bh.IsFriend(from) == false)
                                {
                                    // if the stack we are stepping on has a delta > 3 (stepping off a porch(z=5) onto a stack z6, generate a Penalty point
                                    bool Penalty = false;
                                    if (dest.Z - from.Map.GetAverageZ(dest.X, dest.Y) > 3)
                                        Penalty = true;

                                    TrackPlayer(e, Penalty);
                                }
                            }
                    }
                }
                // case: we are trying to climb item stacks within a multi, maybe a house
                else if (step_off_tile == true && step_on_tile == true)
                {
                    // see if we are stepping onto a stack of movable items
                    // the tile we are stepping on to
                    bool step_onto = false;
                    IPooledEnumerable to_list = from.Map.GetItemsInRange(dest, 0);
                    foreach (Item ix in to_list)
                    {   // we only trap UP movement. If you want UP/DOWN, change ix.Z > from.Z to ix.Z != from.Z
                        if (ix is Item == false) continue;
                        //Console.WriteLine("ON:{0}",ix);
                        if (ix.Z > from.Z && ix.Movable == true)
                        {   // we are stepping onto a movable item at >= OUR Z
                            step_onto = true;
                            break;
                        }
                    }
                    to_list.Free();

                    if (step_onto == true)
                    {
                        // verify if we are climbing in the Z plane
                        int newZ = 0;
                        bool ClimbingZPlane = false;
                        from.CheckMovement(e.Direction, out newZ);
                        // if the players newZ would exceed the closest floor, they are moving up
                        if (newZ > from.Z && newZ > FloorZ(from, dest))
                        {   // make sure there are at least 2 items in this stack at different Zs
                            if (Spells.SpellHelper.iStack(from, dest, 2) == false)
                                ClimbingZPlane = true;
                        }

                        // if we are climbing the z plane
                        if (ClimbingZPlane == true)
                            // if it's a house
                            if (from.Region is Regions.HouseRegion)
                            {   // get the house
                                BaseHouse bh = (from.Region as Regions.HouseRegion).House;
                                // if we are not a friend of this house, block and report
                                if (bh.IsFriend(from) == false)
                                {
                                    // if the stack we are stepping off has a delta > 3 for some reason generate a Penalty point
                                    bool Penalty = false;
                                    if (from.Z - from.Map.GetAverageZ(from.X, from.Y) > 3)
                                        Penalty = true;

                                    TrackPlayer(e, Penalty);
                                }
                            }
                    }
                }

                // done 
                return;

            }
            catch (Exception ex) { EventSink.InvokeLogException(new LogExceptionEventArgs(ex)); }
        }
        private static int FloorZ(Mobile from, Point3D dest)
        {   // find out where all the floors are
            List<int> hardZBreaks = HardZBreaks(from.Map, dest.X, dest.Y, dest.Z);
            // find the floor closest to our Z
            int closest = hardZBreaks.Aggregate((x, y) => Math.Abs(x - from.Z) < Math.Abs(y - from.Z) ? x : y);
            // if the players Z would exceed the closest floor, they are moving up
            return closest;
        }
        private static void TrackPlayer(MovementEventArgs e)
        {
            TrackPlayer(e, false);
        }

        private static void TrackPlayer(MovementEventArgs e, bool Penalty)
        {
            Mobile from = e.Mobile;

            // Look to see if we are already tracking this player
            if (m_doissier.ContainsKey(from.Serial) == false)
                // add it
                m_doissier.Add(from.Serial, new Dossier());

            // okay process this player's Dossier
            Dossier dx = m_doissier[from.Serial];

            // check the timeout
            if (dx.Timeout == true)
            {   // start over with this guy.
                m_doissier.Remove(from.Serial);
                return;
            }

            // Mark the current time
            dx.MarkTime();

            // handle the exploit 3 strikes and you're out
            //  You get a Penalty point if you stepped off a porch onto a stack of > 3 items to begin with
            if ((++dx.InfractionCount + ((Penalty == true) ? 1 : 0)) >= 3)
            {
                BlockAndReport(e);
            }
        }

        private static void BlockAndReport(MovementEventArgs e)
        {
            // block the move
            e.Blocked = true;

            // record the players
            RecordCheater.Cheater(e.Mobile, "Possible Z-Plane Exploit", true);

            // Adam: was getting this spam during an event I was recording.
            //	lets reserve the logging for postmortem analysis
            // Tell staff that an exploit is in progress
            //string text = string.Format("Possible z-plane exploit in progress at {0}. Exploit actions blocked.", e.Mobile.Location.ToString());
            //Server.Commands.CommandHandlers.BroadcastMessage(AccessLevel.Counselor, 0x482, text);
        }
    }

}